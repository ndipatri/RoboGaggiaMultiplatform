/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.ndipatri.kmp.openapi.particle.apis


import com.ndipatri.kmp.openapi.particle.infrastructure.*
import io.ktor.client.HttpClient
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class DefaultApi : ApiClient {

    constructor(
        baseUrl: String = ApiClient.BASE_URL,
        httpClientEngine: HttpClientEngine? = null,
        httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
        jsonSerializer: Json = ApiClient.JSON_DEFAULT
    ) : super(baseUrl = baseUrl, httpClientEngine = httpClientEngine, httpClientConfig = httpClientConfig, jsonBlock = jsonSerializer)

    constructor(
        baseUrl: String,
        httpClient: HttpClient
    ): super(baseUrl = baseUrl, httpClient = httpClient)

    /**
     * Generate a customer scoped access token
     * Creates a token scoped to a customer for your organization.   You must give a valid product OAuth client ID and secret in HTTP Basic Auth or in the client_id and client_secret parameters.
     * @param contentType Must be set to application/x-www-form-urlencoded
     * @param authorization HTTP Basic Auth where username is the OAuth client ID and password is the OAuth client secret.
     * @param grantType 
     * @param clientId  (optional)
     * @param clientSecret  (optional)
     * @param expiresIn  (optional)
     * @param expiresAt  (optional)
     * @param scope  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun oauthTokenPost(contentType: kotlin.String, authorization: kotlin.String, grantType: kotlin.String, clientId: kotlin.String? = null, clientSecret: kotlin.String? = null, expiresIn: kotlin.String? = null, expiresAt: kotlin.String? = null, scope: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>("bearerAuth")

        val localVariableBody = 
            ParametersBuilder().also {
                clientId?.apply { it.append("client_id", clientId.toString()) }
                clientSecret?.apply { it.append("client_secret", clientSecret.toString()) }
                grantType?.apply { it.append("grant_type", grantType.toString()) }
                expiresIn?.apply { it.append("expires_in", expiresIn.toString()) }
                expiresAt?.apply { it.append("expires_at", expiresAt.toString()) }
                scope?.apply { it.append("scope", scope.toString()) }
            }.build()

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/oauth/token",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return urlEncodedFormRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get user
     * Return the user resource for the currently authenticated user.
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun userGet(): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/user",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Forgot password
     * Create a new password reset token and send the user an email with the token. This endpoint is rate-limited to prevent abuse.   Note: This endpoint does not require an access token.
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun userPasswordResetPost(body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/user/password-reset",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Delete user
     * Delete the logged-in user. Allows removing user account and artifacts from Particle system
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun userPut(body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/user",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Delete current access token
     * Delete your currently used token.
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1AccessTokensCurrentDelete(): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v1/access_tokens/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get the current access token information
     * Get your currently used token.
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1AccessTokensCurrentGet(): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/access_tokens/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete all active access tokens
     * Delete all your active access tokens.
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1AccessTokensDelete(): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v1/access_tokens",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List access tokens
     * Retrieve a list of all the issued access tokens for your account   Note: Pass your Particle username and password using HTTP Basic Auth.
     * @param authorization Your Particle username and password
     * @param otp Token given from your MFA device. Usually 6 digits long (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1AccessTokensGet(authorization: kotlin.String, otp: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>("bearerAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        otp?.apply { localVariableQuery["otp"] = listOf("$otp") }
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/access_tokens",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete an access token
     * Delete your unused or lost tokens.   DEPRECATED. Use the DELETE /v1/access_tokens/current endpoint instead.
     * @param token Access Token to delete
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1AccessTokensTokenDelete(token: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v1/access_tokens/{token}".replace("{" + "token" + "}", "$token"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Compile source code
     * Compile source code into a binary for a device
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1BinariesPost(body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/binaries",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * List firmware build targets
     * Lists the firmware versions for all platforms that can be used as build targets during firmware compilation.   Note: This endpoint does not require an access token.
     * @param featured When true, show most relevant (featured) build targets only.
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1BuildTargetsGet(featured: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        featured?.apply { localVariableQuery["featured"] = listOf("$featured") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/build_targets",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete a client
     * Remove an OAuth client
     * @param clientId The client ID to delete
     * @param productIdOrSlug Product ID or slug. Product endpoint only.
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ClientsClientIdDelete(clientId: kotlin.String, productIdOrSlug: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v1/clients/{clientId}".replace("{" + "clientId" + "}", "$clientId").replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Update a client
     * Update the name or scope of an existing OAuth client.
     * @param clientId The client ID to update
     * @param productIdOrSlug Product ID or slug. Product endpoint only.
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ClientsClientIdPut(clientId: kotlin.String, productIdOrSlug: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v1/clients/{clientId}".replace("{" + "clientId" + "}", "$clientId").replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * List clients
     * Get a list of all existing OAuth clients, either owned by the authenticated user or clients associated with a product.
     * @param productIdOrSlug Product ID or slug. Product endpoint only.
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ClientsGet(productIdOrSlug: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/clients".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Create a client
     * Create an OAuth client that represents an app.   Use type&#x3D;installed for most web and mobile apps. If you want to have Particle users login to their account on Particle in order to give your app access to their devices, then you can go through the full OAuth authorization code grant flow using type&#x3D;web. This is the same way you authorize it is similar to the way you give any app access to your Facebook or Twitter account.   Your client secret will never be displayed again! Save it in a safe place.   If you use type&#x3D;web then you will also need to pass a redirect_uri parameter in the POST body. This is the URL where users will be redirected after telling Particle they are willing to give your app access to their devices.   The scopes provided only contain the object and action parts, skipping the domain which is being infered from the context.   If you are building a web or mobile application for your Particle product, you should use the product-specific endpoint for creating a client (POST /v1/products/:productIdOrSlug/clients). This will grant this client (and access tokens generated by this client) access to product-specific behaviors like calling functions and checking variables on product devices, creating customers, and generating customer scoped access tokens.
     * @param productIdOrSlug Product ID or slug. Product endpoint only.
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ClientsPost(productIdOrSlug: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/clients".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Unclaim device
     * Remove ownership of a device. This will unclaim regardless if the device is owned by a user or a customer, in the case of a product.   When using this endpoint to unclaim a product device, the route looks slightly different:   DELETE /v1/products/:productIdOrSlug/devices/:deviceId/owner   Note the /owner at the end of the route.
     * @param deviceId ID of the device to be unclaimed
     * @param productIdOrSlug Product ID or Slug
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1DevicesDeviceIdDelete(deviceId: kotlin.String, productIdOrSlug: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v1/devices/{deviceId}".replace("{" + "deviceId" + "}", "$deviceId").replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get a stream of events for a device
     * Open a stream of Server Sent Events for all events for the specified device.
     * @param deviceId Device ID
     * @param eventPrefix Filters the stream to only events starting with the specified prefix
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1DevicesDeviceIdEventsEventPrefixGet(deviceId: kotlin.String, eventPrefix: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/devices/{deviceId}/events/{eventPrefix}".replace("{" + "deviceId" + "}", "$deviceId").replace("{" + "eventPrefix" + "}", "$eventPrefix"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Call a function
     * Call a function exposed by the device, with arguments passed in the request body. Functions can be called on a device you own, or for any device that is part of a product you are a team member of.
     * @param deviceId 
     * @param functionName 
     * @param productIdOrSlug Product ID or Slug. Product endpoint only.
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1DevicesDeviceIdFunctionNamePost(deviceId: kotlin.String, functionName: kotlin.String, productIdOrSlug: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/devices/{deviceId}/{functionName}".replace("{" + "deviceId" + "}", "$deviceId").replace("{" + "functionName" + "}", "$functionName").replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Get device information
     * Get basic information about the given device, including the custom variables and functions it has exposed. This can be called for sandbox devices claimed to your account and for product devices you have access to, regardless of claiming.
     * @param deviceId Device ID
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1DevicesDeviceIdGet(deviceId: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/devices/{deviceId}".replace("{" + "deviceId" + "}", "$deviceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Ping a device
     * This will ping a device, enabling you to see if your device is online or offline
     * @param deviceId 
     * @param productIdOrSlug Product ID or Slug. Product endpoint only.
     * @param contentType 
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1DevicesDeviceIdPingPut(deviceId: kotlin.String, productIdOrSlug: kotlin.String, contentType: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v1/devices/{deviceId}/ping".replace("{" + "deviceId" + "}", "$deviceId").replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Flash a device with a bundle
     * Update the device firmware from a bundle
     * @param deviceId Device ID
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1DevicesDeviceIdPut(deviceId: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v1/devices/{deviceId}".replace("{" + "deviceId" + "}", "$deviceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Get a variable value
     * Request the current value of a variable exposed by the device. Variables can be read on a device you own, or for any device that is part of a product you are a team member of.
     * @param deviceId Device ID
     * @param varName Variable name
     * @param productIdOrSlug Product ID or Slug. Product endpoint only.
     * @param format Specify raw if you just the value returned (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1DevicesDeviceIdVarNameGet(deviceId: kotlin.String, varName: kotlin.String, productIdOrSlug: kotlin.String, format: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        format?.apply { localVariableQuery["format"] = listOf("$format") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/devices/{deviceId}/{varName}".replace("{" + "deviceId" + "}", "$deviceId").replace("{" + "varName" + "}", "$varName").replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get a stream of your events
     * Open a stream of Server Sent Events for all events for your devices.
     * @param eventPrefix Filters the stream to only events starting with the specified prefix. Omit to get all events.
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1DevicesEventsEventPrefixGet(eventPrefix: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/devices/events/{eventPrefix}".replace("{" + "eventPrefix" + "}", "$eventPrefix"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Publish an event
     * Publish an event
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1DevicesEventsPost(body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/devices/events",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * List devices
     * List devices the currently authenticated user has access to. By default, devices will be sorted by last_handshake_at in descending order.
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1DevicesGet(): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>("bearerAuth")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/devices",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Claim a device
     * Claim a new or unclaimed device to your account.
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1DevicesPost(body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/devices",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Get all historical device vitals
     * Returns all stored device vital records sent by the device to the Device Cloud. Device vitals records will expire after 1 month.
     * @param deviceId Device ID
     * @param productIdOrSlug Product ID or slug. Product endpoint only
     * @param accept Optionally set to text/csv to return historic device vitals as a CSV
     * @param startDate Oldest diagnostic to return, inclusive. Date in ISO8601 format. (optional)
     * @param endDate Newest diagnostic to return, exclusive. Date in ISO8601 format. (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1DiagnosticsDeviceIdGet(deviceId: kotlin.String, productIdOrSlug: kotlin.String, accept: kotlin.String, startDate: kotlin.String? = null, endDate: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        startDate?.apply { localVariableQuery["start_date"] = listOf("$startDate") }
        endDate?.apply { localVariableQuery["end_date"] = listOf("$endDate") }
        val localVariableHeaders = mutableMapOf<String, String>()
        accept?.apply { localVariableHeaders["Accept"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/diagnostics/{deviceId}".replace("{" + "deviceId" + "}", "$deviceId").replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get last known device vitals
     * Returns the last device vitals payload sent by the device to the Device Cloud.
     * @param deviceId Device ID
     * @param productIdOrSlug Product ID or slug. Product endpoint only
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1DiagnosticsDeviceIdLastGet(deviceId: kotlin.String, productIdOrSlug: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/diagnostics/{deviceId}/last".replace("{" + "deviceId" + "}", "$deviceId").replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Refresh device vitals
     * Refresh diagnostic vitals for a single device. This will instruct the device to publish a new event to the Device Cloud containing a device vitals payload. This is an asynchronous request: the HTTP request returns immediately after the request to the device is sent. In order for the device to respond with a vitals payload, it must be online and connected to the Device Cloud.   The device will respond by publishing an event named spark/device/diagnostics/update. See the description of the device vitals event.
     * @param deviceId Device ID
     * @param productIdOrSlug Product ID or slug. Product endpoint only
     * @param contentType 
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1DiagnosticsDeviceIdUpdatePost(deviceId: kotlin.String, productIdOrSlug: kotlin.String, contentType: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/diagnostics/{deviceId}/update".replace("{" + "deviceId" + "}", "$deviceId").replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get a stream of events
     * Open a stream of Server Sent Events for all events. for your devices matching the filter.   Note that as of April 2018, the event prefix filter is required. It was optional before.
     * @param eventPrefix Filters the stream to only events starting with the specified prefix. The event prefix filter is required for this endpoint.
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1EventsEventPrefixGet(eventPrefix: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/events/{eventPrefix}".replace("{" + "eventPrefix" + "}", "$eventPrefix"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List integrations
     * List all integrations. Pay special attention to the integration_type attribute of each integration, which will let you know whether the integration is a Webhook, an Azure IoT Hub integration, or a Google Cloud Platform integration.   If you would like to only list webhooks (integrations with type: &#39;Webhook&#39;), you can use a slightly different endpoint:   GET /v1/webhooks
     * @param productIdOrSlug Product ID or slug. Product endpoint only.
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1IntegrationsGet(productIdOrSlug: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/integrations".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete an integration
     * Delete an integration and immediate stop it from triggering. The integration can belong to a user or to a product.
     * @param integrationId The ID of the desired integration
     * @param productIdOrSlug Product ID or slug (only for product webhooks)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1IntegrationsIntegrationIdDelete(integrationId: kotlin.String, productIdOrSlug: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v1/integrations/{integrationId}".replace("{" + "integrationId" + "}", "$integrationId").replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get integration
     * Get a single integration. Pay special attention to the integration_type attribute of each integration, which will let you know whether the integration is a Webhook, an Azure IoT Hub integration, a Google Cloud Platform integration, or a Google Maps integration.
     * @param integrationId The ID of the desired integration
     * @param productIdOrSlug Product ID or slug. Product endpoint only.
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1IntegrationsIntegrationIdGet(integrationId: kotlin.String, productIdOrSlug: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/integrations/{integrationId}".replace("{" + "integrationId" + "}", "$integrationId").replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Edit Google Maps Integration
     * Edit a Google Maps integration. Subsequent triggering of this integration will be sent with the new attributes.   The configuration replaces the entire previous webhook configuration. It does not merge in changes.
     * @param integrationId The ID of the desired integration
     * @param productIdOrSlug Product ID or slug. Product endpoint only.
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1IntegrationsIntegrationIdPut(integrationId: kotlin.String, productIdOrSlug: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v1/integrations/{integrationId}".replace("{" + "integrationId" + "}", "$integrationId").replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Test an integration
     * Send a test event that triggers the integration. Helps build confidence that an integration is configured properly.
     * @param integrationId The ID of the desired integration
     * @param productIdOrSlug Product ID or slug. Product endpoint only.
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1IntegrationsIntegrationIdTestPost(integrationId: kotlin.String, productIdOrSlug: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/integrations/{integrationId}/test".replace("{" + "integrationId" + "}", "$integrationId").replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Enable Google Maps integration
     * Enable an integration with Google Maps. For more details, check out the tutorial.
     * @param productIdOrSlug Product ID or slug. Product endpoint only.
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1IntegrationsPost(productIdOrSlug: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/integrations".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * List organizations
     * List organizations the currently authenticated user has access to
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1OrgsGet(): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/orgs",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Retrieve an organization
     * Retrieve details for an organization.
     * @param orgIdOrSlug Organization ID or Slug
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1OrgsOrgIdOrSlugGet(orgIdOrSlug: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/orgs/{orgIdOrSlug}".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List organization products
     * List products which belong the the organization
     * @param orgIdOrSlug Organization ID or Slug
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1OrgsOrgIdOrSlugProductsGet(orgIdOrSlug: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/orgs/{orgIdOrSlug}/products".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get organization service agreements
     * Get the service agreements related to an organization
     * @param orgIdOrSlug Org ID or Slug
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1OrgsOrgIdOrSlugServiceAgreementsGet(orgIdOrSlug: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/orgs/{orgIdOrSlug}/service_agreements".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Create an org usage report
     * Request a new usage report related to the organization service agreement.   The usage report will be processed asynchronously. Expect its \&quot;state\&quot; to change throughout time.   The user must be an active member of the organization.
     * @param orgSlugOrId Organization Slug or ID
     * @param serviceAgreementId Service Agreement ID
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1OrgsOrgSlugOrIdServiceAgreementsServiceAgreementIdUsageReportsPost(orgSlugOrId: kotlin.String, serviceAgreementId: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/orgs/{orgSlugOrId}/service_agreements/{serviceAgreementId}/usage_reports".replace("{" + "orgSlugOrId" + "}", "$orgSlugOrId").replace("{" + "serviceAgreementId" + "}", "$serviceAgreementId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Get an org usage report
     * Get a single usage report related to an organization. Expect \&quot;download_url\&quot; to be present only when the usage report has an \&quot;available\&quot; state.   The user must be an active member of the organization.
     * @param usageReportId The usage report ID
     * @param orgSlugOrId Organization Slug or ID
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1OrgsOrgSlugOrIdUsageReportsUsageReportIdGet(usageReportId: kotlin.String, orgSlugOrId: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/orgs/{orgSlugOrId}/usage_reports/{usageReportId}".replace("{" + "usageReportId" + "}", "$usageReportId").replace("{" + "orgSlugOrId" + "}", "$orgSlugOrId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete product configuration schema
     * Delete configuration schema, use Tracker Edge defaults.
     * @param productIdOrSlug Product ID or slug.
     * @param contentType Must be set to \&quot;application/schema+json\&quot; for this endpoint.
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugConfigDelete(productIdOrSlug: kotlin.String, contentType: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v1/products/{productIdOrSlug}/config".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete device configuration schema
     * Delete device&#39;s configuration schema, use product&#39;s.
     * @param productIdOrSlug Product ID or slug.
     * @param deviceId The device ID to delete the schema.
     * @param contentType Must be set to \&quot;application/schema+json\&quot; for this endpoint.
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugConfigDeviceIdDelete(productIdOrSlug: kotlin.String, deviceId: kotlin.String, contentType: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v1/products/{productIdOrSlug}/config/{deviceId}".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug").replace("{" + "deviceId" + "}", "$deviceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get device schema
     * Get the possible values that can be configured for one device in this product, in JSON Schema format
     * @param productIdOrSlug Product ID or slug.
     * @param deviceId The device ID to query.
     * @param accept Must be set to \&quot;application/schema+json\&quot; for this endpoint
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugConfigDeviceIdGet(productIdOrSlug: kotlin.String, deviceId: kotlin.String, accept: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        accept?.apply { localVariableHeaders["Accept"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/products/{productIdOrSlug}/config/{deviceId}".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug").replace("{" + "deviceId" + "}", "$deviceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Set device configuration schema
     * Set configuration schema for the device.   This must be the entire schema, including the standard Particle parts; there is no merging of changes.
     * @param productIdOrSlug Product ID or slug.
     * @param deviceId Device ID
     * @param contentType Must be set to \&quot;application/schema+json\&quot; for this endpoint.
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugConfigDeviceIdPut(productIdOrSlug: kotlin.String, deviceId: kotlin.String, contentType: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v1/products/{productIdOrSlug}/config/{deviceId}".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug").replace("{" + "deviceId" + "}", "$deviceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get product schema
     * Get the possible values that can be configured for this product, in JSON Schema format
     * @param productIdOrSlug Product ID or slug.
     * @param accept Must be set to \&quot;application/schema+json\&quot; for this endpoint
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugConfigGet(productIdOrSlug: kotlin.String, accept: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        accept?.apply { localVariableHeaders["Accept"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/products/{productIdOrSlug}/config".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Set product configuration schema
     * Set configuration schema that will become the default for the product.   This must be the entire schema, including the standard Particle parts; there is no merging of changes.
     * @param productIdOrSlug Product ID or slug.
     * @param contentType Must be set to \&quot;application/schema+json\&quot; for this endpoint.
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugConfigPut(productIdOrSlug: kotlin.String, contentType: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v1/products/{productIdOrSlug}/config".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete a customer
     * Delete a customer in a product. Will also revoke all of this customer&#39;s access tokens, pending device claim codes and activation codes.
     * @param productIdOrSlug Product ID or Slug
     * @param customerEmail Email of the customer account that you&#39;d like to remove
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugCustomersCustomerEmailDelete(productIdOrSlug: kotlin.String, customerEmail: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v1/products/{productIdOrSlug}/customers/{customerEmail}".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug").replace("{" + "customerEmail" + "}", "$customerEmail"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Update customer password
     * Update the account password for a customer. Only relevant for non-shadow customers that have a password saved in Particle&#39;s system. Must be called with an access token that has access to the product, not a customer access token.
     * @param productIdOrSlug Product ID or Slug
     * @param customerEmail Email of the customer account that you&#39;d like to update
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugCustomersCustomerEmailPut(productIdOrSlug: kotlin.String, customerEmail: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v1/products/{productIdOrSlug}/customers/{customerEmail}".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug").replace("{" + "customerEmail" + "}", "$customerEmail"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * List customers for a product
     * List Customers for a product.
     * @param productIdOrSlug Product ID or Slug
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugCustomersGet(productIdOrSlug: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/products/{productIdOrSlug}/customers".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Create a customer - Implicit
     * Create a customer for a product using OAuth implicit grant type. This is the way you should hit the POST customers endpoint if you are creating customers from a web browser. After a successful POST, the customer access token will be appended as a hash to the redirect URI associated with the client credentials provided. For this grant type, you must also pass response_type: token.   You must give a valid product OAuth client ID in HTTP Basic Auth or in the client_id parameter. Do not pass the OAuth client secret when creating customers from a web browser.
     * @param productIdOrSlug Product ID or Slug
     * @param authorization HTTP Basic Auth where username is the OAuth client ID and password is blank.
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugCustomersPost(productIdOrSlug: kotlin.String, authorization: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>("bearerAuth")

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["Authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/products/{productIdOrSlug}/customers".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Deny a quarantined device
     * Deny a quarantined device
     * @param productIdOrSlug Product ID or Slug
     * @param deviceId ID of the device to be denied
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugDevicesDeviceIdDelete(productIdOrSlug: kotlin.String, deviceId: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v1/products/{productIdOrSlug}/devices/{deviceId}".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug").replace("{" + "deviceId" + "}", "$deviceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get product device information
     * Get basic information about a given device that is part of a product   See Get device information for the response attributes
     * @param deviceId Device ID
     * @param productIdOrSlug Product ID or Slug
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugDevicesDeviceIdGet(deviceId: kotlin.String, productIdOrSlug: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/products/{productIdOrSlug}/devices/{deviceId}".replace("{" + "deviceId" + "}", "$deviceId").replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Assign groups to a device
     * Update group memberships for an individual device. This is an absolute endpoint, meaning that regardless of previous group memberships, the group names passed to this endpoint will be the ones assigned to the device.   If you pass a group name that does not yet exist, it will be created and assigned to the device.
     * @param deviceId Device ID
     * @param productIdOrSlug Product ID or slug
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugDevicesDeviceIdPut(deviceId: kotlin.String, productIdOrSlug: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v1/products/{productIdOrSlug}/devices/{deviceId}".replace("{" + "deviceId" + "}", "$deviceId").replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * List devices in a product
     * List all devices that are part of a product. Results are paginated, by default returns 25 device records per page.
     * @param productIdOrSlug Product ID or Slug
     * @param deviceId Filter results to devices with this ID (partial matching) (optional)
     * @param groups Comma separated list of full group names to filter results to devices belonging to these groups only (optional)
     * @param deviceName Filter results to devices with this name (partial matching) (optional)
     * @param serialNumber Filter results to devices with this serial number (partial matching) (optional)
     * @param sortAttr The attribute by which to sort results. Options for sorting are deviceName, deviceId, firmwareVersion, or lastConnection. By default, if no sortAttr parameter is set, devices will be sorted by last connection, in descending order (optional)
     * @param sortDir The direction of sorting. Pass asc for ascending sorting or desc for descending sorting (optional)
     * @param quarantined include / exclude quarantined devices (optional)
     * @param page Current page of results (optional)
     * @param perPage Records per page (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugDevicesGet(productIdOrSlug: kotlin.String, deviceId: kotlin.String? = null, groups: kotlin.String? = null, deviceName: kotlin.String? = null, serialNumber: kotlin.String? = null, sortAttr: kotlin.String? = null, sortDir: kotlin.String? = null, quarantined: kotlin.String? = null, page: kotlin.String? = null, perPage: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        deviceId?.apply { localVariableQuery["deviceId"] = listOf("$deviceId") }
        groups?.apply { localVariableQuery["groups"] = listOf("$groups") }
        deviceName?.apply { localVariableQuery["deviceName"] = listOf("$deviceName") }
        serialNumber?.apply { localVariableQuery["serialNumber"] = listOf("$serialNumber") }
        sortAttr?.apply { localVariableQuery["sortAttr"] = listOf("$sortAttr") }
        sortDir?.apply { localVariableQuery["sortDir"] = listOf("$sortDir") }
        quarantined?.apply { localVariableQuery["quarantined"] = listOf("$quarantined") }
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        perPage?.apply { localVariableQuery["perPage"] = listOf("$perPage") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/products/{productIdOrSlug}/devices".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Approve a quarantined device
     * Approve a quarantined device. This will immediately release the device from quarantine and allow it to publish events, receive firmware updates, etc.
     * @param productIdOrSlug Product ID or Slug
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugDevicesPost(productIdOrSlug: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/products/{productIdOrSlug}/devices".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Batch assign groups to devices
     * Assign groups to devices in a product as a batch action. Groups can either be added or removed from all devices passed to the endpoint.
     * @param productIdOrSlug Product ID or slug
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugDevicesPut(productIdOrSlug: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v1/products/{productIdOrSlug}/devices".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Product event stream
     * Open a stream of Server Sent Events for all events for a product.
     * @param productIdOrSlug Product ID or slug
     * @param eventPrefix Filters the stream to only events starting with the specified prefix
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugEventsEventPrefixGet(productIdOrSlug: kotlin.String, eventPrefix: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/products/{productIdOrSlug}/events/{eventPrefix}".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug").replace("{" + "eventPrefix" + "}", "$eventPrefix"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Publish a product event
     * Publish an event that is sent to the product&#39;s event stream
     * @param productIdOrSlug Product ID or slug.
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugEventsPost(productIdOrSlug: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/products/{productIdOrSlug}/events".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * List all product firmwares
     * List all versions of product firmware
     * @param productIdOrSlug Product ID or slug
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugFirmwareGet(productIdOrSlug: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/products/{productIdOrSlug}/firmware".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Upload product firmware
     * Upload a new firmware version to a product
     * @param productIdOrSlug Product ID or slug
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugFirmwarePost(productIdOrSlug: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/products/{productIdOrSlug}/firmware".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Release product firmware
     * Release a version of firmware to the fleet of product devices. When releasing as the product default, all non-development devices that are not individually locked to a version of product firmware will automatically download and run this version of firmware the next time they handshake with the cloud.   You can also release firmware to specific groups for more fine-grained firmware management.   Note: Before releasing firmware for the first time, the firmware must be running on at least one device in your product fleet that has successfully re-connected to the Particle cloud.
     * @param productIdOrSlug Product ID or slug
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugFirmwareReleasePut(productIdOrSlug: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v1/products/{productIdOrSlug}/firmware/release".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Download firmware binary
     * Retrieve and download the original binary of a version of product firmware.
     * @param productIdOrSlug Product ID or slug
     * @param version Version number of firmware to retrieve
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugFirmwareVersionBinaryGet(productIdOrSlug: kotlin.String, version: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/products/{productIdOrSlug}/firmware/{version}/binary".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug").replace("{" + "version" + "}", "$version"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete unreleased firmware binary
     * Delete a version of product firmware that has never been released.
     * @param productIdOrSlug Product ID or slug
     * @param version Version number of firmware to delete
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugFirmwareVersionDelete(productIdOrSlug: kotlin.String, version: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v1/products/{productIdOrSlug}/firmware/{version}".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug").replace("{" + "version" + "}", "$version"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get product firmware
     * Get a specific version of product firmware
     * @param productIdOrSlug Product ID or slug
     * @param version Version number of firmware to retrieve
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugFirmwareVersionGet(productIdOrSlug: kotlin.String, version: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/products/{productIdOrSlug}/firmware/{version}".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug").replace("{" + "version" + "}", "$version"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Edit product firmware
     * Edit a specific product firmware version
     * @param productIdOrSlug Product ID or slug
     * @param version Version number of the firmware to edit
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugFirmwareVersionPut(productIdOrSlug: kotlin.String, version: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v1/products/{productIdOrSlug}/firmware/{version}".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug").replace("{" + "version" + "}", "$version"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Query fleet-wide locations for devices within a product
     * Get the latest location data for all the devices in a product to get a fleet-wide summary of device location.
     * @param productIdOrSlug Product ID or slug.
     * @param deviceId Device ID prefix to include in the query (optional)
     * @param deviceName Device name prefix to include in the query (optional)
     * @param groups Array of group names to include in the query (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugFleetLocationsGet(productIdOrSlug: kotlin.String, deviceId: kotlin.String? = null, deviceName: kotlin.String? = null, groups: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        deviceId?.apply { localVariableQuery["device_id"] = listOf("$deviceId") }
        deviceName?.apply { localVariableQuery["device_name"] = listOf("$deviceName") }
        groups?.apply { localVariableQuery["groups"] = listOf("$groups") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/products/{productIdOrSlug}/fleet_locations".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Retrieve a product
     * Retrieve details for a product.
     * @param productIdOrSlug Product ID or Slug
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugGet(productIdOrSlug: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/products/{productIdOrSlug}".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List device groups
     * List the group objects that exist in the product. Optionally, filter by group name (partial match).
     * @param productIdOrSlug Product ID or slug
     * @param name String to filter group names by. Partial string matching. (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugGroupsGet(productIdOrSlug: kotlin.String, name: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        name?.apply { localVariableQuery["name"] = listOf("$name") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/products/{productIdOrSlug}/groups".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete device group
     * Delete device group. All devices that belong to this group will be removed from the deleted group.
     * @param productIdOrSlug Product ID or slug
     * @param groupName The group name to delete
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugGroupsGroupNameDelete(productIdOrSlug: kotlin.String, groupName: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v1/products/{productIdOrSlug}/groups/{groupName}".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug").replace("{" + "groupName" + "}", "$groupName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get device group
     * Retrieve full info on a specific product group, including its device count.
     * @param productIdOrSlug Product ID or slug
     * @param groupName The group name to fetch
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugGroupsGroupNameGet(productIdOrSlug: kotlin.String, groupName: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/products/{productIdOrSlug}/groups/{groupName}".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug").replace("{" + "groupName" + "}", "$groupName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Edit device group
     * Edit attributes of a specific device group. You must pass one of name, color, or description.
     * @param productIdOrSlug Product ID or slug
     * @param groupName The group name to edit
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugGroupsGroupNamePut(productIdOrSlug: kotlin.String, groupName: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v1/products/{productIdOrSlug}/groups/{groupName}".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug").replace("{" + "groupName" + "}", "$groupName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Create device group
     * Create a new device group withinin a product
     * @param productIdOrSlug Product ID or slug
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugGroupsPost(productIdOrSlug: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/products/{productIdOrSlug}/groups".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Impact of taking action
     * Understand the number of devices that would receive an over-the-air update as a result of taking an action related to device groups.   Currently, this endpoint supports understanding the impact of releasing/unreleasing firmware to one or more device groups. Pass edit_groups_for_firmware as the action parameter when calling the endpoint.
     * @param productIdOrSlug Product ID or slug
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugImpactGet(productIdOrSlug: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/products/{productIdOrSlug}/impact".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Query location for one device within a product
     * Get last known or historical location data for one device. Date range and bounding box can be specified to narrow down the query. Properties and custom data will be returned by default.
     * @param productIdOrSlug Product ID or slug.
     * @param deviceId Device ID
     * @param dateRange Start and end date in ISO8601 format, separated by comma, to query. Omitting date_range will return last known location. (optional)
     * @param rectBl Bottom left of the rectangular bounding box to query. Latitude and longitude separated by comma. (optional)
     * @param rectTr Top right of the rectangular bounding box to query. Latitude and longitude separated by comma. (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugLocationsDeviceIdGet(productIdOrSlug: kotlin.String, deviceId: kotlin.String, dateRange: kotlin.String? = null, rectBl: kotlin.String? = null, rectTr: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        dateRange?.apply { localVariableQuery["date_range"] = listOf("$dateRange") }
        rectBl?.apply { localVariableQuery["rect_bl"] = listOf("$rectBl") }
        rectTr?.apply { localVariableQuery["rect_tr"] = listOf("$rectTr") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/products/{productIdOrSlug}/locations/{deviceId}".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug").replace("{" + "deviceId" + "}", "$deviceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Query location for devices within a product
     * Get latest or historical location data for devices. Date range and bounding box can be specified to narrow the query.
     * @param productIdOrSlug Product ID or slug.
     * @param dateRange Start and end date in ISO8601 format, separated by comma, to query. Omitting date_range will return last known location. (optional)
     * @param rectBl Bottom left of the rectangular bounding box to query. Latitude and longitude separated by comma. (optional)
     * @param rectTr Top right of the rectangular bounding box to query. Latitude and longitude separated by comma. (optional)
     * @param deviceId Device ID prefix to include in the query (optional)
     * @param deviceName Device name prefix to include in the query (optional)
     * @param groups Array of group names to include in the query (optional)
     * @param page Page of results to display. Defaults to 1 (optional)
     * @param perPage Number of results per page. Defaults to 20. Maximum of 100 (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugLocationsGet(productIdOrSlug: kotlin.String, dateRange: kotlin.String? = null, rectBl: kotlin.String? = null, rectTr: kotlin.String? = null, deviceId: kotlin.String? = null, deviceName: kotlin.String? = null, groups: kotlin.String? = null, page: kotlin.String? = null, perPage: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        dateRange?.apply { localVariableQuery["date_range"] = listOf("$dateRange") }
        rectBl?.apply { localVariableQuery["rect_bl"] = listOf("$rectBl") }
        rectTr?.apply { localVariableQuery["rect_tr"] = listOf("$rectTr") }
        deviceId?.apply { localVariableQuery["device_id"] = listOf("$deviceId") }
        deviceName?.apply { localVariableQuery["device_name"] = listOf("$deviceName") }
        groups?.apply { localVariableQuery["groups"] = listOf("$groups") }
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        perPage?.apply { localVariableQuery["per_page"] = listOf("$perPage") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/products/{productIdOrSlug}/locations".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get event traffic health metrics
     * Reports each time a device publishes an event in this product.   Each time bucket contains counts of:   - received: the cloud received an event from a device.   Can be filtered to include only events from devices with a certain firmware version, Device OS version or in a certain group.
     * @param productIdOrSlug Product ID or slug.
     * @param startDate DateTime to start on (inclusive), defaults to the current time. Date in ISO8601 format. (optional)
     * @param endDate DateTime to end on (inclusive), defaults to the current time. Date in ISO8601 format. (optional)
     * @param bucketSize Number of seconds for each bucket, defaults to 900 (15 minutes). Must be greater than 15. (optional)
     * @param productFw Filter for this product firmware version. (optional)
     * @param deviceOsVersion Filter for this Device OS version. (optional)
     * @param deviceGroup Filter for this device group. (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugMetricsEventsGet(productIdOrSlug: kotlin.String, startDate: kotlin.String? = null, endDate: kotlin.String? = null, bucketSize: kotlin.String? = null, productFw: kotlin.String? = null, deviceOsVersion: kotlin.String? = null, deviceGroup: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        startDate?.apply { localVariableQuery["start_date"] = listOf("$startDate") }
        endDate?.apply { localVariableQuery["end_date"] = listOf("$endDate") }
        bucketSize?.apply { localVariableQuery["bucket_size"] = listOf("$bucketSize") }
        productFw?.apply { localVariableQuery["product_fw"] = listOf("$productFw") }
        deviceOsVersion?.apply { localVariableQuery["device_os_version"] = listOf("$deviceOsVersion") }
        deviceGroup?.apply { localVariableQuery["device_group"] = listOf("$deviceGroup") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/products/{productIdOrSlug}/metrics/events".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get cloud function call health metrics
     * Reports each time a Particle.function() in firmware is called on a device in this product and the outcome.   Each time bucket contains counts of (keys with a value of 0 will be omitted):   - success: the target device successfully received and responded to the function call. - failure: the target device was unable to process the function call, or was unreachable by the cloud. - offline: the function call attempt was skipped because the device was not connected to the cloud at the time the call was made.   Can be filtered to include only function calls for devices with a certain firmware version, Device OS version or in a certain group.
     * @param productIdOrSlug Product ID or slug.
     * @param startDate DateTime to start on (inclusive), defaults to the current time. Date in ISO8601 format. (optional)
     * @param endDate DateTime to end on (inclusive), defaults to the current time. Date in ISO8601 format. (optional)
     * @param bucketSize Number of seconds for each bucket, defaults to 900 (15 minutes). Must be greater than 15. (optional)
     * @param productFw Filter for this product firmware version. (optional)
     * @param deviceOsVersion Filter for this Device OS version. (optional)
     * @param deviceGroup Filter for this device group. (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugMetricsFunctionsGet(productIdOrSlug: kotlin.String, startDate: kotlin.String? = null, endDate: kotlin.String? = null, bucketSize: kotlin.String? = null, productFw: kotlin.String? = null, deviceOsVersion: kotlin.String? = null, deviceGroup: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        startDate?.apply { localVariableQuery["start_date"] = listOf("$startDate") }
        endDate?.apply { localVariableQuery["end_date"] = listOf("$endDate") }
        bucketSize?.apply { localVariableQuery["bucket_size"] = listOf("$bucketSize") }
        productFw?.apply { localVariableQuery["product_fw"] = listOf("$productFw") }
        deviceOsVersion?.apply { localVariableQuery["device_os_version"] = listOf("$deviceOsVersion") }
        deviceGroup?.apply { localVariableQuery["device_group"] = listOf("$deviceGroup") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/products/{productIdOrSlug}/metrics/functions".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get integration traffic health metrics
     * Reports outbound integration requests that are sent on behalf of this product fleet and the outcome.   Each time bucket contains counts of (keys with a value of 0 will be omitted):   - success: the integration request was accepted by the destination service (2xx response code). - failure: the integration request was rejected by the destination service (network error, 4xx or 5xx response code) after 3 attempts. - sleep (skipped): the integration request was not attempted because there have been too many previous failures in rapid succession.   Can be filtered to include only integrations triggered by devices with a certain firmware version, Device OS version or in a certain group.
     * @param productIdOrSlug Product ID or slug.
     * @param startDate DateTime to start on (inclusive), defaults to the current time. Date in ISO8601 format. (optional)
     * @param endDate DateTime to end on (inclusive), defaults to the current time. Date in ISO8601 format. (optional)
     * @param bucketSize Number of seconds for each bucket, defaults to 900 (15 minutes). Must be greater than 15. (optional)
     * @param productFw Filter for this product firmware version. (optional)
     * @param deviceOsVersion Filter for this Device OS version. (optional)
     * @param deviceGroup Filter for this device group. (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugMetricsIntegrationGet(productIdOrSlug: kotlin.String, startDate: kotlin.String? = null, endDate: kotlin.String? = null, bucketSize: kotlin.String? = null, productFw: kotlin.String? = null, deviceOsVersion: kotlin.String? = null, deviceGroup: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        startDate?.apply { localVariableQuery["start_date"] = listOf("$startDate") }
        endDate?.apply { localVariableQuery["end_date"] = listOf("$endDate") }
        bucketSize?.apply { localVariableQuery["bucket_size"] = listOf("$bucketSize") }
        productFw?.apply { localVariableQuery["product_fw"] = listOf("$productFw") }
        deviceOsVersion?.apply { localVariableQuery["device_os_version"] = listOf("$deviceOsVersion") }
        deviceGroup?.apply { localVariableQuery["device_group"] = listOf("$deviceGroup") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/products/{productIdOrSlug}/metrics/integration".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get online devices metrics
     * Reports the number of devices online in this product.   Each time bucket contains:   - count: the number of devices with an active cloud connection.   Devices that recently went offline (due to being powered off or losing network connectivity) will be counted as online until the device misses sending a keep-alive message to the cloud. This is typically 25 seconds for Wi-Fi networks and 23 minutes for cellular networks.   Can be filtered to include only devices with a certain firmware version, Device OS version or in a certain group.
     * @param productIdOrSlug Product ID or slug.
     * @param startDate DateTime to start on (inclusive), defaults to the current time. Date in ISO8601 format. (optional)
     * @param endDate DateTime to end on (inclusive), defaults to the current time. Date in ISO8601 format. (optional)
     * @param bucketSize Number of seconds for each bucket, defaults to 900 (15 minutes). Must be greater than 15. (optional)
     * @param productFw Filter for this product firmware version. (optional)
     * @param deviceOsVersion Filter for this Device OS version. (optional)
     * @param deviceGroup Filter for this device group. (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugMetricsOnlineGet(productIdOrSlug: kotlin.String, startDate: kotlin.String? = null, endDate: kotlin.String? = null, bucketSize: kotlin.String? = null, productFw: kotlin.String? = null, deviceOsVersion: kotlin.String? = null, deviceGroup: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        startDate?.apply { localVariableQuery["start_date"] = listOf("$startDate") }
        endDate?.apply { localVariableQuery["end_date"] = listOf("$endDate") }
        bucketSize?.apply { localVariableQuery["bucket_size"] = listOf("$bucketSize") }
        productFw?.apply { localVariableQuery["product_fw"] = listOf("$productFw") }
        deviceOsVersion?.apply { localVariableQuery["device_os_version"] = listOf("$deviceOsVersion") }
        deviceGroup?.apply { localVariableQuery["device_group"] = listOf("$deviceGroup") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/products/{productIdOrSlug}/metrics/online".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get cloud variable request health metrics
     * Reports each time a Particle.variable() in firmware is read on a device in this product and the outcome.   Each time bucket contains counts of (keys with a value of 0 will be omitted):   - success: the target device successfully received and responded to the variable request. - failure: the target device was unable to process the variable request, or was unreachable by the cloud. - offline: the variable request was skipped because the device was not connected to the cloud at the time the call was made.   Can be filtered to include only variable requests for devices with a certain firmware version, Device OS version or in a certain group.
     * @param productIdOrSlug Product ID or slug.
     * @param startDate DateTime to start on (inclusive), defaults to the current time. Date in ISO8601 format. (optional)
     * @param endDate DateTime to end on (inclusive), defaults to the current time. Date in ISO8601 format. (optional)
     * @param bucketSize Number of seconds for each bucket, defaults to 900 (15 minutes). Must be greater than 15. (optional)
     * @param productFw Filter for this product firmware version. (optional)
     * @param deviceOsVersion Filter for this Device OS version. (optional)
     * @param deviceGroup Filter for this device group. (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugMetricsVariablesGet(productIdOrSlug: kotlin.String, startDate: kotlin.String? = null, endDate: kotlin.String? = null, bucketSize: kotlin.String? = null, productFw: kotlin.String? = null, deviceOsVersion: kotlin.String? = null, deviceGroup: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        startDate?.apply { localVariableQuery["start_date"] = listOf("$startDate") }
        endDate?.apply { localVariableQuery["end_date"] = listOf("$endDate") }
        bucketSize?.apply { localVariableQuery["bucket_size"] = listOf("$bucketSize") }
        productFw?.apply { localVariableQuery["product_fw"] = listOf("$productFw") }
        deviceOsVersion?.apply { localVariableQuery["device_os_version"] = listOf("$deviceOsVersion") }
        deviceGroup?.apply { localVariableQuery["device_group"] = listOf("$deviceGroup") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/products/{productIdOrSlug}/metrics/variables".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get data usage for product fleet
     * Get fleet-wide SIM card data usage for a product in the current billing period, broken out by day. Daily usage totals represent an aggregate of all SIM cards that make up the product. Data usage reports can be delayed until the next day, and occasionally by several days.
     * @param productIdOrSlug Product ID or slug
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugSimsDataUsageGet(productIdOrSlug: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/products/{productIdOrSlug}/sims/data_usage".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Import and activate product SIMs
     * Import a group of SIM cards into a product. SIM cards will be activated upon import. Either pass an array of ICCIDs or include a file containing a list of SIM cards.   Import and activation will be queued for processing. You will receive an email with the import results when all SIM cards have been processed.   Importing a SIM card associated with a device will also import the device into the product.
     * @param productIdOrSlug Product ID or slug
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugSimsPost(productIdOrSlug: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/products/{productIdOrSlug}/sims".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * List team members
     * List all team members that are part of a given product. Also, will retrieve all API users for all the products inside the org
     * @param productIdOrSlug Product ID or slug
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugTeamGet(productIdOrSlug: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/products/{productIdOrSlug}/team".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Create an API user
     * Create an API user with specified scopes. This API user will have a single non-expiring access token.
     * @param productIdOrSlug Product ID or Slug
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugTeamPost(productIdOrSlug: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/products/{productIdOrSlug}/team".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Remove team member
     * Remove a current team member.
     * @param productIdOrSlug Product ID or Slug
     * @param username Username of the team member to be removed
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugTeamUsernameDelete(productIdOrSlug: kotlin.String, username: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v1/products/{productIdOrSlug}/team/{username}".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug").replace("{" + "username" + "}", "$username"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Update team member
     * Update a current team member.
     * @param productIdOrSlug Product ID or Slug
     * @param username Username of the team member to be updated
     * @param contentType 
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugTeamUsernamePost(productIdOrSlug: kotlin.String, username: kotlin.String, contentType: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/products/{productIdOrSlug}/team/{username}".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug").replace("{" + "username" + "}", "$username"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Regenerate programmatic user&#39;s token
     * Regenerate programmatic users token
     * @param productIdOrSlug Product ID or Slug
     * @param username Username of the team member to be updated
     * @param contentType 
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1ProductsProductIdOrSlugTeamUsernameTokenPut(productIdOrSlug: kotlin.String, username: kotlin.String, contentType: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        contentType?.apply { localVariableHeaders["Content-Type"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v1/products/{productIdOrSlug}/team/{username}/token".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug").replace("{" + "username" + "}", "$username"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Look up device identification from a serial number
     * Return the device ID and SIM card ICCD (if applicable) for a device by serial number. This API can look up devices that you have not yet added to your product and is rate limited to 50 requests per hour. Once you&#39;ve imported your devices to your product you should instead use the list devices in a product API and filter on serial number. No special rate limits apply to that API.
     * @param serialNumber The serial number printed on the barcode of the device packaging.
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1SerialNumbersSerialNumberGet(serialNumber: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/serial_numbers/{serial_number}".replace("{" + "serial_number" + "}", "$serialNumber"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List SIM cards
     * Get a list of the SIM cards owned by an individual or a product. The product endpoint is paginated, by default returns 25 SIM card records per page.
     * @param productIdOrSlug Product ID or slug. Product endpoint only
     * @param iccid Filter results to SIMs with this ICCID (partial matching) (optional)
     * @param deviceId Filter results to SIMs with this associated device ID (partial matching) (optional)
     * @param deviceName Filter results to SIMs with this associated device name (partial matching) (optional)
     * @param page Current page of results (optional)
     * @param perPage Records per page (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1SimsGet(productIdOrSlug: kotlin.String, iccid: kotlin.String? = null, deviceId: kotlin.String? = null, deviceName: kotlin.String? = null, page: kotlin.String? = null, perPage: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        iccid?.apply { localVariableQuery["iccid"] = listOf("$iccid") }
        deviceId?.apply { localVariableQuery["deviceId"] = listOf("$deviceId") }
        deviceName?.apply { localVariableQuery["deviceName"] = listOf("$deviceName") }
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        perPage?.apply { localVariableQuery["perPage"] = listOf("$perPage") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/sims".replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get data usage
     * Get SIM card data usage for the current billing period, broken out by day. Note that date usage reports can be delayed by up to 1 hour.
     * @param iccid The ICCID of the desired SIM
     * @param productIdOrSlug Product ID or slug. Product endpoint only
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1SimsIccidDataUsageGet(iccid: kotlin.String, productIdOrSlug: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/sims/{iccid}/data_usage".replace("{" + "iccid" + "}", "$iccid").replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Release SIM from account
     * Remove a SIM card from an account, disassociating the SIM card from a user or a product. The SIM will also be deactivated.   Once the SIM card has been released, it can be claimed by a different user, or imported into a different product.
     * @param iccid The ICCID of the desired SIM
     * @param productIdOrSlug Product ID or slug. Product endpoint only
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1SimsIccidDelete(iccid: kotlin.String, productIdOrSlug: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v1/sims/{iccid}".replace("{" + "iccid" + "}", "$iccid").replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get SIM information
     * Retrieve a SIM card owned by an individual or a product.
     * @param iccid Filter results to SIMs with this ICCID (partial matching) Product endpoint only
     * @param productIdOrSlug Product ID or slug. Product endpoint only
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1SimsIccidGet(iccid: kotlin.String, productIdOrSlug: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/sims/{iccid}".replace("{" + "iccid" + "}", "$iccid").replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Reactivate SIM
     * Re-enables a SIM card to connect to a cell tower. Do this if you&#39;d like to reactivate a SIM that you have deactivated.
     * @param iccid The ICCID of the SIM to update
     * @param productIdOrSlug Product ID or slug. Product endpoint only
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1SimsIccidPut(iccid: kotlin.String, productIdOrSlug: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v1/sims/{iccid}".replace("{" + "iccid" + "}", "$iccid").replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Get cellular network status
     * Get cellular network status for a given device. Kicks off a long running task that checks if the device/SIM has an active data session with a cell tower. Values for keys in the sim_status object will be null until the task has finished. Poll the endpoint until meta.state is complete. At this point, the sim_status object will be populated.   Note that responses are cached by the cellular network providers. This means that on occasion, the real-time status of the device/SIM may not align with the results of this test.
     * @param iccid The ICCID of the desired SIM
     * @param productIdOrSlug Product ID or slug. Product endpoint only
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1SimsIccidStatusGet(iccid: kotlin.String, productIdOrSlug: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/sims/{iccid}/status".replace("{" + "iccid" + "}", "$iccid").replace("{" + "productIdOrSlug" + "}", "$productIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List products
     * List products the currently authenticated user has access to
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UserProductsGet(): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/user/products",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get user service agreements
     * Get the service agreements related to a user
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UserServiceAgreementsGet(): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/user/service_agreements",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get notifications for current usage period
     * Get user notifications related to a specific service agreement   - Usage reached a certain threshold (70%, 90%, 100%) - Service was paused - Service was unpaused
     * @param serviceAgreementId Service agreement ID
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UserServiceAgreementsServiceAgreementIdNotificationsGet(serviceAgreementId: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/user/service_agreements/{serviceAgreementId}/notifications".replace("{" + "serviceAgreementId" + "}", "$serviceAgreementId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Create a user usage report
     * Request a new usage report related to the user service agreement.   The usage report will be processed asynchronously. Expect its \&quot;state\&quot; to change throughout time.
     * @param serviceAgreementId Service Agreement ID
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UserServiceAgreementsServiceAgreementIdUsageReportsPost(serviceAgreementId: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/user/service_agreements/{serviceAgreementId}/usage_reports".replace("{" + "serviceAgreementId" + "}", "$serviceAgreementId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Get a user usage report
     * Get a single usage report related to the user. Expect \&quot;download_url\&quot; to be present only when the usage report has an \&quot;available\&quot; state.
     * @param usageReportId The usage report ID
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UserUsageReportsUsageReportIdGet(usageReportId: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/user/usage_reports/{usageReportId}".replace("{" + "usageReportId" + "}", "$usageReportId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List ledger definitions
     * Lists all ledger definitions belonging to the Sandbox or organization.
     * @param orgIdOrSlug Organization ID or Slug. Organization endpoint only.
     * @param page Page number (optional)
     * @param perPage Number of definitions per page (optional)
     * @param archived Filter for archived definitions (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UsersLedgersGet(orgIdOrSlug: kotlin.String, page: kotlin.String? = null, perPage: kotlin.String? = null, archived: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        perPage?.apply { localVariableQuery["perPage"] = listOf("$perPage") }
        archived?.apply { localVariableQuery["archived"] = listOf("$archived") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/users/ledgers".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Archive a ledger definition
     * Archives a ledger definition.
     * @param orgIdOrSlug Organization ID or Slug. Organization endpoint only.
     * @param ledgerName Ledger name
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UsersLedgersLedgerNameDelete(orgIdOrSlug: kotlin.String, ledgerName: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v1/users/ledgers/{ledgerName}".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug").replace("{" + "ledgerName" + "}", "$ledgerName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get ledger definition
     * Returns the specified ledger definition.
     * @param orgIdOrSlug Organization ID or Slug. Organization endpoint only.
     * @param ledgerName Ledger name
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UsersLedgersLedgerNameGet(orgIdOrSlug: kotlin.String, ledgerName: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/users/ledgers/{ledgerName}".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug").replace("{" + "ledgerName" + "}", "$ledgerName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List ledger instances
     * Lists all ledger instances.
     * @param orgIdOrSlug Organization ID or Slug. Organization endpoint only.
     * @param ledgerName Ledger name
     * @param page Page number (optional)
     * @param perPage Number of instances per page (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UsersLedgersLedgerNameInstancesGet(orgIdOrSlug: kotlin.String, ledgerName: kotlin.String, page: kotlin.String? = null, perPage: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        perPage?.apply { localVariableQuery["perPage"] = listOf("$perPage") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/users/ledgers/{ledgerName}/instances".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug").replace("{" + "ledgerName" + "}", "$ledgerName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete ledger instance
     * Deletes the specified ledger instance.
     * @param orgIdOrSlug Organization ID or Slug. Organization endpoint only.
     * @param ledgerName Ledger name
     * @param scopeValue Scope value
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UsersLedgersLedgerNameInstancesScopeValueDelete(orgIdOrSlug: kotlin.String, ledgerName: kotlin.String, scopeValue: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v1/users/ledgers/{ledgerName}/instances/{scopeValue}".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug").replace("{" + "ledgerName" + "}", "$ledgerName").replace("{" + "scopeValue" + "}", "$scopeValue"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get ledger instance
     * Returns the specified ledger instance.
     * @param orgIdOrSlug Organization ID or Slug. Organization endpoint only.
     * @param ledgerName Ledger name
     * @param scopeValue Scope value
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UsersLedgersLedgerNameInstancesScopeValueGet(orgIdOrSlug: kotlin.String, ledgerName: kotlin.String, scopeValue: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/users/ledgers/{ledgerName}/instances/{scopeValue}".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug").replace("{" + "ledgerName" + "}", "$ledgerName").replace("{" + "scopeValue" + "}", "$scopeValue"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Set the ledger instance data
     * Sets the data of the specified ledger instance.
     * @param orgIdOrSlug Organization ID or Slug. Organization endpoint only.
     * @param ledgerName Ledger name
     * @param scopeValue Scope value
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UsersLedgersLedgerNameInstancesScopeValuePut(orgIdOrSlug: kotlin.String, ledgerName: kotlin.String, scopeValue: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v1/users/ledgers/{ledgerName}/instances/{scopeValue}".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug").replace("{" + "ledgerName" + "}", "$ledgerName").replace("{" + "scopeValue" + "}", "$scopeValue"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * List ledger instance versions
     * Lists all ledger instance versions.
     * @param orgIdOrSlug Organization ID or Slug. Organization endpoint only.
     * @param ledgerName Ledger name
     * @param scopeValue Scope value
     * @param replacedBefore List only versions replaced before this date (optional)
     * @param replacedAfter List only versions replaced after this date (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UsersLedgersLedgerNameInstancesScopeValueVersionsGet(orgIdOrSlug: kotlin.String, ledgerName: kotlin.String, scopeValue: kotlin.String, replacedBefore: kotlin.String? = null, replacedAfter: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        replacedBefore?.apply { localVariableQuery["replaced_before"] = listOf("$replacedBefore") }
        replacedAfter?.apply { localVariableQuery["replaced_after"] = listOf("$replacedAfter") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/users/ledgers/{ledgerName}/instances/{scopeValue}/versions".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug").replace("{" + "ledgerName" + "}", "$ledgerName").replace("{" + "scopeValue" + "}", "$scopeValue"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get ledger instance version
     * Returns the specified version of a ledger instance.
     * @param orgIdOrSlug Organization ID or Slug. Organization endpoint only.
     * @param ledgerName Ledger name
     * @param scopeValue Scope value
     * @param version Version ID
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UsersLedgersLedgerNameInstancesScopeValueVersionsVersionGet(orgIdOrSlug: kotlin.String, ledgerName: kotlin.String, scopeValue: kotlin.String, version: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/users/ledgers/{ledgerName}/instances/{scopeValue}/versions/{version}".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug").replace("{" + "ledgerName" + "}", "$ledgerName").replace("{" + "scopeValue" + "}", "$scopeValue").replace("{" + "version" + "}", "$version"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Update ledger definition
     * Updates the ledger definition.
     * @param orgIdOrSlug Organization ID or Slug. Organization endpoint only.
     * @param ledgerName Ledger name
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UsersLedgersLedgerNamePut(orgIdOrSlug: kotlin.String, ledgerName: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v1/users/ledgers/{ledgerName}".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug").replace("{" + "ledgerName" + "}", "$ledgerName"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Create a new ledger definition
     * Creates a ledger definition.
     * @param orgIdOrSlug Organization ID or Slug. Organization endpoint only.
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UsersLedgersPost(orgIdOrSlug: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/users/ledgers".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Execute logic function
     * Executes the provided logic function.
     * @param orgIdOrSlug Organization ID or Slug. Organization endpoint only.
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UsersLogicExecutePost(orgIdOrSlug: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/users/logic/execute".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * List logic functions
     * Lists all logic functions belonging to the specified Sandbox or organization.
     * @param orgIdOrSlug Organization ID or Slug. Organization endpoint only.
     * @param todayStats Include today&#39;s stats (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UsersLogicFunctionsGet(orgIdOrSlug: kotlin.String, todayStats: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        todayStats?.apply { localVariableQuery["today_stats"] = listOf("$todayStats") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/users/logic/functions".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete logic function
     * Deletes the specified logic function.
     * @param orgIdOrSlug Organization ID or Slug. Organization endpoint only.
     * @param logicFunctionId Logic function ID
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UsersLogicFunctionsLogicFunctionIdDelete(orgIdOrSlug: kotlin.String, logicFunctionId: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v1/users/logic/functions/{logicFunctionId}".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug").replace("{" + "logicFunctionId" + "}", "$logicFunctionId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get logic function
     * Returns the specified logic function.
     * @param orgIdOrSlug Organization ID or Slug. Organization endpoint only.
     * @param logicFunctionId Logic function ID
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UsersLogicFunctionsLogicFunctionIdGet(orgIdOrSlug: kotlin.String, logicFunctionId: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/users/logic/functions/{logicFunctionId}".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug").replace("{" + "logicFunctionId" + "}", "$logicFunctionId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Update logic function
     * Updates the logic function.
     * @param orgIdOrSlug Organization ID or Slug. Organization endpoint only.
     * @param logicFunctionId Logic function ID
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UsersLogicFunctionsLogicFunctionIdPut(orgIdOrSlug: kotlin.String, logicFunctionId: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v1/users/logic/functions/{logicFunctionId}".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug").replace("{" + "logicFunctionId" + "}", "$logicFunctionId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * List logic functions runs
     * Lists all runs for the specified logic function.
     * @param orgIdOrSlug Organization ID or Slug. Organization endpoint only.
     * @param logicFunctionId Logic function ID
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UsersLogicFunctionsLogicFunctionIdRunsGet(orgIdOrSlug: kotlin.String, logicFunctionId: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/users/logic/functions/{logicFunctionId}/runs".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug").replace("{" + "logicFunctionId" + "}", "$logicFunctionId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get logic function run
     * Returns the specified logic function run.
     * @param orgIdOrSlug Organization ID or Slug. Organization endpoint only.
     * @param logicFunctionId Logic function ID
     * @param logicRunId Logic run ID
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UsersLogicFunctionsLogicFunctionIdRunsLogicRunIdGet(orgIdOrSlug: kotlin.String, logicFunctionId: kotlin.String, logicRunId: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/users/logic/functions/{logicFunctionId}/runs/{logicRunId}".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug").replace("{" + "logicFunctionId" + "}", "$logicFunctionId").replace("{" + "logicRunId" + "}", "$logicRunId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get logic function run logs
     * Returns the specified logic function run logs.
     * @param orgIdOrSlug Organization ID or Slug. Organization endpoint only.
     * @param logicFunctionId Logic function ID
     * @param logicRunId Logic run ID
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UsersLogicFunctionsLogicFunctionIdRunsLogicRunIdLogsGet(orgIdOrSlug: kotlin.String, logicFunctionId: kotlin.String, logicRunId: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/users/logic/functions/{logicFunctionId}/runs/{logicRunId}/logs".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug").replace("{" + "logicFunctionId" + "}", "$logicFunctionId").replace("{" + "logicRunId" + "}", "$logicRunId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get logic function stats
     * Returns the specified logic function stats.
     * @param orgIdOrSlug Organization ID or Slug. Organization endpoint only.
     * @param logicFunctionId Logic function ID
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UsersLogicFunctionsLogicFunctionIdStatsGet(orgIdOrSlug: kotlin.String, logicFunctionId: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/users/logic/functions/{logicFunctionId}/stats".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug").replace("{" + "logicFunctionId" + "}", "$logicFunctionId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Create a new logic function
     * Creates a logic function.
     * @param orgIdOrSlug Organization ID or Slug. Organization endpoint only.
     * @param body  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun v1UsersLogicFunctionsPost(orgIdOrSlug: kotlin.String, body: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = body

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/users/logic/functions".replace("{" + "orgIdOrSlug" + "}", "$orgIdOrSlug"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



}
